/*
 * aiqna db for web service (Blog Tables)
 * Database Name 'aiqna'
 *
 * Created 2024-09-24
 * Updated 2025-12-01
 * 
 * 테이블:
 *   1. blog_post              - 블로그 포스트 메타데이터
 * 
 * 함수:
 *   - upsert_blog_post_data()        - 포스트 데이터 저장
 *   - upsert_blog_post_ai_analysis() - AI 분석 결과 저장
 */


-- ╔═══════════════════════════════════════════════════════════════════════════╗
-- ║                                                                           ║
-- ║                           1. BLOG_POST 테이블                              ║
-- ║                                                                           ║
-- ╚═══════════════════════════════════════════════════════════════════════════╝

/*
 ***********************************************************************************************
 * TABLE: blog_post
 ***********************************************************************************************
 * 설명: 블로그 포스트 메타데이터 저장
 * 데이터 소스: 블로그 크롤링 (네이버, 티스토리 등)
 * 
 * 섹션:
 *   - 기본 정보 (URL, 제목, 본문)
 *   - 플랫폼 정보 (네이버, 티스토리 등)
 *   - 작성자 정보
 *   - Open Graph 메타데이터
 *   - AI 분석 결과 (ai_*)
 ***********************************************************************************************
 */
CREATE TABLE IF NOT EXISTS public.blog_post (
    -- ========================================
    -- 기본 키
    -- ========================================
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    post_url TEXT NOT NULL,                     -- 포스트 전체 URL
    
    -- ========================================
    -- 포스트 기본 정보
    -- ========================================
    title TEXT NULL,                            -- 제목
    content TEXT NULL,                          -- 본문 내용
    excerpt TEXT NULL,                          -- 요약/발췌문
    tags TEXT[] NULL,                           -- 태그 배열
    published_date TIMESTAMPTZ NULL,            -- 게시 일시
    modified_date TIMESTAMPTZ NULL,             -- 수정 일시
    
    -- ========================================
    -- 플랫폼 정보
    -- ========================================
    platform VARCHAR(50) NULL,                  -- naver, tistory, brunch, velog 등
    platform_post_id VARCHAR(100) NULL,         -- 플랫폼별 포스트 ID
    platform_url TEXT NULL,                     -- 플랫폼 메인 URL
    
    -- ========================================
    -- 작성자 정보
    -- ========================================
    author_id VARCHAR(100) NULL,                -- 작성자 ID
    author_name VARCHAR(255) NULL,              -- 작성자 이름/닉네임
    author_profile_url TEXT NULL,               -- 작성자 프로필 URL
    blog_name VARCHAR(255) NULL,                -- 블로그 이름
    blog_url TEXT NULL,                         -- 블로그 메인 URL
    
    -- ========================================
    -- 통계 정보
    -- ========================================
    view_count BIGINT NOT NULL DEFAULT 0,
    like_count BIGINT NOT NULL DEFAULT 0,
    comment_count BIGINT NOT NULL DEFAULT 0,
    share_count BIGINT NOT NULL DEFAULT 0,
    
    -- ========================================
    -- 미디어 정보
    -- ========================================
    thumbnail_url TEXT NULL,                    -- 대표 이미지
    image_urls TEXT[] NULL,                     -- 본문 내 이미지 URL 배열
    image_count INTEGER NOT NULL DEFAULT 0,
    has_video BOOLEAN NOT NULL DEFAULT FALSE,
    
    -- ========================================
    -- Open Graph 메타데이터
    -- ========================================
    og_title TEXT NULL,
    og_description TEXT NULL,
    og_image TEXT NULL,
    og_url TEXT NULL,
    og_type VARCHAR(50) NULL,                   -- article, blog 등
    og_site_name VARCHAR(255) NULL,
    
    -- ========================================
    -- AI 분석 결과 - 콘텐츠 요약
    -- ========================================
    ai_summary TEXT NULL,                       -- 포스트 전체 요약 (제목 + 본문 기반)
    ai_key_points TEXT[] NULL,                  -- 핵심 포인트 배열
    
    ai_meta_category TEXT[] NULL,               -- 카테고리 ['맛집', '관광', '카페']
    ai_meta_influencer TEXT[] NULL,             -- 언급된 인플루언서
    ai_meta_season TEXT[] NULL,                 -- 적합한 계절 ['봄', '가을']
    ai_meta_time_of_day TEXT[] NULL,            -- 적합한 시간대 ['아침', '저녁']
    ai_meta_activity_type TEXT[] NULL,          -- 활동 유형 ['데이트', '가족여행', '혼행']
    ai_meta_special_tag TEXT[] NULL,            -- 특수 태그 ['맛집리뷰', '여행기', '일상']
    ai_meta_kpop TEXT[] NULL,                   -- K-POP 관련 태그 ['BTS', 'BLACKPINK', 'EXO']
    ai_meta_target_age TEXT[] NULL,             -- 타겟 연령 ['20대', '30대', '40대', '50대', '60대 이상']
    ai_meta_target_audience TEXT[] NULL,        -- 타겟 ['20대', '커플', '외국인']
    ai_meta_landmark TEXT[] NULL,               -- 랜드마크 ['광화문', '경복궁', '창덕궁']
    ai_meta_city TEXT[] NULL,                   -- 도시 ['서울', '부산', '인천']
    ai_meta_country TEXT[] NULL,                -- 국가 ['대한민국', '미국', '일본']
    ai_meta_district TEXT[] NULL,               -- 구 ['종로구', '강남구', '서초구']
    ai_meta_neighborhood TEXT[] NULL,           -- 동 ['세종로', '강남동', '서초동']
    ai_meta_place TEXT[] NULL,                  -- 장소 ['경복궁', '을지로 골뱅이', '카페 온마']
    
    -- ========================================
    -- AI 분석 결과 - 장소별 상세 정보
    -- ========================================
    ai_places JSONB NULL,                       -- 장소 상세 정보
    ai_places_count SMALLINT NULL,              -- 장소 개수 (쿼리 최적화용)
    /*
    ai_places 구조: (youtube_video와 동일)
    [
        {
            "place_name": "을지로 골뱅이",
            "place_name_en": "Euljiro Golbaengi",
            "place_name_native": null,
            "place_type": "restaurant",
            "country": "KR",
            "city": "서울",
            "district": "중구",
            "neighborhood": "을지로",
            "landmark": "을지로3가역 근처",
            "address": "서울특별시 중구 을지로 123",
            "latitude": 37.5665,
            "longitude": 126.9780,
            "period": null,
            "start_date": null,
            "end_date": null,
            "operation_hours": "17:00-24:00",
            "prices": {"골뱅이무침": 15000, "소주": 5000, "currency": "KRW"},
            "recommend_menu": ["골뱅이무침", "계란찜"],
            "travel_tips": ["예약 필수", "웨이팅 있음"],
            "notice": "일요일 휴무",
            "review_summary": "을지로 맛집으로 유명",
            "reservation_required": true,
            "order_in_post": 1
        }
    ]
    */
    
    -- ========================================
    -- AI 분석 메타
    -- ========================================
    ai_analyzed_at TIMESTAMPTZ NULL,
    ai_model VARCHAR(50) NULL,
    ai_confidence NUMERIC(3,2) NULL,            -- 0.00 ~ 1.00
    
    -- ========================================
    -- 로컬 저장 정보 (선택적)
    -- ========================================
    local_thumbnail_path TEXT NULL,             -- 로컬 저장된 썸네일 경로
    local_content_path TEXT NULL,               -- 로컬 저장된 본문 경로 (HTML/MD)
    
    -- ========================================
    -- 시스템 관리
    -- ========================================
    metadata_json JSONB NULL,                   -- 원본 크롤링 데이터 (디버깅용)
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
    deleted_at TIMESTAMPTZ NULL,
    
    -- ========================================
    -- 시스템 타임스탬프
    -- ========================================
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_processed_at TIMESTAMPTZ NULL,

    -- ========================================
    -- 제약조건
    -- ========================================
    CONSTRAINT bp_post_url_unique 
        UNIQUE (post_url),
    CONSTRAINT bp_platform_post_unique 
        UNIQUE (platform, platform_post_id),
    CONSTRAINT bp_platform_check 
        CHECK (platform IS NULL OR platform IN ('naver', 'tistory', 'brunch', 'velog', 'medium', 'wordpress', 'other')),
    CONSTRAINT bp_view_count_check 
        CHECK (view_count >= 0),
    CONSTRAINT bp_like_count_check 
        CHECK (like_count >= 0),
    CONSTRAINT bp_comment_count_check 
        CHECK (comment_count >= 0),
    CONSTRAINT bp_share_count_check 
        CHECK (share_count >= 0),
    CONSTRAINT bp_image_count_check 
        CHECK (image_count >= 0),
    CONSTRAINT bp_ai_places_count_check
        CHECK (ai_places_count IS NULL OR ai_places_count >= 0),
    CONSTRAINT bp_ai_confidence_check
        CHECK (ai_confidence IS NULL OR (ai_confidence >= 0 AND ai_confidence <= 1)),
    CONSTRAINT bp_deleted_logic_check
        CHECK (
            (is_deleted = FALSE AND deleted_at IS NULL) 
            OR (is_deleted = TRUE AND deleted_at IS NOT NULL)
        )
);

-- ========================================
-- 인덱스: blog_post
-- ========================================
-- 기본 검색 인덱스
CREATE INDEX IF NOT EXISTS idx_bp_post_url 
    ON public.blog_post (post_url);
CREATE INDEX IF NOT EXISTS idx_bp_published_date 
    ON public.blog_post (published_date);
CREATE INDEX IF NOT EXISTS idx_bp_platform 
    ON public.blog_post (platform);
CREATE INDEX IF NOT EXISTS idx_bp_platform_post_id 
    ON public.blog_post (platform, platform_post_id);
CREATE INDEX IF NOT EXISTS idx_bp_author_id 
    ON public.blog_post (author_id);
CREATE INDEX IF NOT EXISTS idx_bp_author_name 
    ON public.blog_post (author_name);
CREATE INDEX IF NOT EXISTS idx_bp_blog_name 
    ON public.blog_post (blog_name);

-- 조건부 인덱스 (Partial Index)
CREATE INDEX IF NOT EXISTS idx_bp_is_active 
    ON public.blog_post (is_active) 
    WHERE is_active = TRUE;
CREATE INDEX IF NOT EXISTS idx_bp_is_deleted 
    ON public.blog_post (is_deleted) 
    WHERE is_deleted = FALSE;
CREATE INDEX IF NOT EXISTS idx_bp_has_video 
    ON public.blog_post (has_video) 
    WHERE has_video = TRUE;
CREATE INDEX IF NOT EXISTS idx_bp_ai_analyzed_at
    ON public.blog_post (ai_analyzed_at)
    WHERE ai_analyzed_at IS NOT NULL;

-- 배열 컬럼 GIN 인덱스
CREATE INDEX IF NOT EXISTS idx_bp_tags_gin 
    ON public.blog_post USING GIN (tags);
CREATE INDEX IF NOT EXISTS idx_bp_image_urls_gin 
    ON public.blog_post USING GIN (image_urls);
CREATE INDEX IF NOT EXISTS idx_bp_ai_meta_category_gin
    ON public.blog_post USING GIN (ai_meta_category);
CREATE INDEX IF NOT EXISTS idx_bp_ai_meta_activity_type_gin
    ON public.blog_post USING GIN (ai_meta_activity_type);
CREATE INDEX IF NOT EXISTS idx_bp_ai_meta_special_tag_gin
    ON public.blog_post USING GIN (ai_meta_special_tag);
CREATE INDEX IF NOT EXISTS idx_bp_ai_meta_city_gin
    ON public.blog_post USING GIN (ai_meta_city);
CREATE INDEX IF NOT EXISTS idx_bp_ai_meta_landmark_gin
    ON public.blog_post USING GIN (ai_meta_landmark);
CREATE INDEX IF NOT EXISTS idx_bp_ai_meta_place_gin
    ON public.blog_post USING GIN (ai_meta_place);

-- JSONB GIN 인덱스
CREATE INDEX IF NOT EXISTS idx_bp_ai_places_gin 
    ON public.blog_post USING GIN (ai_places);
CREATE INDEX IF NOT EXISTS idx_bp_metadata_json_gin 
    ON public.blog_post USING GIN (metadata_json);

-- 전체 텍스트 검색 인덱스
CREATE INDEX IF NOT EXISTS idx_bp_text_search_gin 
    ON public.blog_post USING GIN (
        to_tsvector('simple', 
            COALESCE(title, '') || ' ' || 
            COALESCE(excerpt, '') || ' ' ||
            COALESCE(blog_name, '') || ' ' ||
            COALESCE(author_name, '')
        )
    );

-- ========================================
-- RLS: blog_post
-- ========================================
ALTER TABLE public.blog_post ENABLE ROW LEVEL SECURITY;

CREATE POLICY "blog_post is visible to everyone" 
    ON public.blog_post FOR SELECT 
    TO authenticated, anon 
    USING (TRUE);

CREATE POLICY "Service role can manage blog_post" 
    ON public.blog_post FOR ALL 
    TO service_role 
    USING (TRUE) 
    WITH CHECK (TRUE);

-- ========================================
-- 트리거: blog_post updated_at 자동 갱신
-- ========================================
CREATE OR REPLACE FUNCTION update_blog_post_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_bp_updated_at
    BEFORE UPDATE ON public.blog_post
    FOR EACH ROW
    EXECUTE FUNCTION update_blog_post_updated_at();





-- ╔═══════════════════════════════════════════════════════════════════════════╗
-- ║                                                                           ║
-- ║                        2. BLOG_POST 관련 함수                              ║
-- ║                                                                           ║
-- ╚═══════════════════════════════════════════════════════════════════════════╝

/*
 ***********************************************************************************************
 * FUNCTION: 블로그 포스트 데이터 Upsert
 ***********************************************************************************************
 * 설명: 크롤링 데이터를 blog_post 테이블에 저장
 * 용도: 데이터 fetch 후 호출
 * 
 * 반환: {success, id, post_url}
 ***********************************************************************************************
 */
CREATE OR REPLACE FUNCTION upsert_blog_post_data(
    p_post_url TEXT,
    p_title TEXT DEFAULT NULL,
    p_content TEXT DEFAULT NULL,
    p_excerpt TEXT DEFAULT NULL,
    p_tags TEXT[] DEFAULT NULL,
    p_published_date TIMESTAMPTZ DEFAULT NULL,
    p_modified_date TIMESTAMPTZ DEFAULT NULL,
    p_platform VARCHAR(50) DEFAULT NULL,
    p_platform_post_id VARCHAR(100) DEFAULT NULL,
    p_platform_url TEXT DEFAULT NULL,
    p_author_id VARCHAR(100) DEFAULT NULL,
    p_author_name VARCHAR(255) DEFAULT NULL,
    p_author_profile_url TEXT DEFAULT NULL,
    p_blog_name VARCHAR(255) DEFAULT NULL,
    p_blog_url TEXT DEFAULT NULL,
    p_view_count BIGINT DEFAULT 0,
    p_like_count BIGINT DEFAULT 0,
    p_comment_count BIGINT DEFAULT 0,
    p_share_count BIGINT DEFAULT 0,
    p_thumbnail_url TEXT DEFAULT NULL,
    p_image_urls TEXT[] DEFAULT NULL,
    p_image_count INTEGER DEFAULT 0,
    p_has_video BOOLEAN DEFAULT FALSE,
    p_og_title TEXT DEFAULT NULL,
    p_og_description TEXT DEFAULT NULL,
    p_og_image TEXT DEFAULT NULL,
    p_og_url TEXT DEFAULT NULL,
    p_og_type VARCHAR(50) DEFAULT NULL,
    p_og_site_name VARCHAR(255) DEFAULT NULL,
    p_metadata_json JSONB DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
    v_id BIGINT;
BEGIN
    -- post_url 필수 체크
    IF p_post_url IS NULL OR p_post_url = '' THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'post_url is required'
        );
    END IF;

    -- Upsert
    INSERT INTO public.blog_post (
        post_url,
        title,
        content,
        excerpt,
        tags,
        published_date,
        modified_date,
        platform,
        platform_post_id,
        platform_url,
        author_id,
        author_name,
        author_profile_url,
        blog_name,
        blog_url,
        view_count,
        like_count,
        comment_count,
        share_count,
        thumbnail_url,
        image_urls,
        image_count,
        has_video,
        og_title,
        og_description,
        og_image,
        og_url,
        og_type,
        og_site_name,
        metadata_json,
        last_processed_at
    ) VALUES (
        p_post_url,
        p_title,
        p_content,
        p_excerpt,
        p_tags,
        p_published_date,
        p_modified_date,
        p_platform,
        p_platform_post_id,
        p_platform_url,
        p_author_id,
        p_author_name,
        p_author_profile_url,
        p_blog_name,
        p_blog_url,
        p_view_count,
        p_like_count,
        p_comment_count,
        p_share_count,
        p_thumbnail_url,
        p_image_urls,
        p_image_count,
        p_has_video,
        p_og_title,
        p_og_description,
        p_og_image,
        p_og_url,
        p_og_type,
        p_og_site_name,
        p_metadata_json,
        NOW()
    )
    ON CONFLICT (post_url) DO UPDATE SET
        title = COALESCE(EXCLUDED.title, public.blog_post.title),
        content = COALESCE(EXCLUDED.content, public.blog_post.content),
        excerpt = COALESCE(EXCLUDED.excerpt, public.blog_post.excerpt),
        tags = COALESCE(EXCLUDED.tags, public.blog_post.tags),
        published_date = COALESCE(EXCLUDED.published_date, public.blog_post.published_date),
        modified_date = COALESCE(EXCLUDED.modified_date, public.blog_post.modified_date),
        platform = COALESCE(EXCLUDED.platform, public.blog_post.platform),
        platform_post_id = COALESCE(EXCLUDED.platform_post_id, public.blog_post.platform_post_id),
        platform_url = COALESCE(EXCLUDED.platform_url, public.blog_post.platform_url),
        author_id = COALESCE(EXCLUDED.author_id, public.blog_post.author_id),
        author_name = COALESCE(EXCLUDED.author_name, public.blog_post.author_name),
        author_profile_url = COALESCE(EXCLUDED.author_profile_url, public.blog_post.author_profile_url),
        blog_name = COALESCE(EXCLUDED.blog_name, public.blog_post.blog_name),
        blog_url = COALESCE(EXCLUDED.blog_url, public.blog_post.blog_url),
        view_count = EXCLUDED.view_count,
        like_count = EXCLUDED.like_count,
        comment_count = EXCLUDED.comment_count,
        share_count = EXCLUDED.share_count,
        thumbnail_url = COALESCE(EXCLUDED.thumbnail_url, public.blog_post.thumbnail_url),
        image_urls = COALESCE(EXCLUDED.image_urls, public.blog_post.image_urls),
        image_count = EXCLUDED.image_count,
        has_video = EXCLUDED.has_video,
        og_title = COALESCE(EXCLUDED.og_title, public.blog_post.og_title),
        og_description = COALESCE(EXCLUDED.og_description, public.blog_post.og_description),
        og_image = COALESCE(EXCLUDED.og_image, public.blog_post.og_image),
        og_url = COALESCE(EXCLUDED.og_url, public.blog_post.og_url),
        og_type = COALESCE(EXCLUDED.og_type, public.blog_post.og_type),
        og_site_name = COALESCE(EXCLUDED.og_site_name, public.blog_post.og_site_name),
        metadata_json = COALESCE(EXCLUDED.metadata_json, public.blog_post.metadata_json),
        last_processed_at = NOW()
    RETURNING id INTO v_id;

    RETURN jsonb_build_object(
        'success', true,
        'id', v_id,
        'post_url', p_post_url
    );
END;
$$;

COMMENT ON FUNCTION upsert_blog_post_data IS 
'블로그 포스트 데이터를 blog_post 테이블에 저장';


/*
 ***********************************************************************************************
 * FUNCTION: AI 분석 결과 저장
 ***********************************************************************************************
 * 설명: AI 분석 결과를 blog_post 테이블의 ai_* 필드에 저장
 * 용도: AI 분석 완료 후 호출
 * 
 * 파라미터: 모든 파라미터는 선택적 (NULL이면 기존 값 유지)
 * 반환: {success, post_url, places_count} 또는 {success: false, error}
 ***********************************************************************************************
 */
CREATE OR REPLACE FUNCTION upsert_blog_post_ai_analysis(
    p_post_url TEXT,
    p_ai_summary TEXT DEFAULT NULL,
    p_ai_key_points TEXT[] DEFAULT NULL,
    p_ai_meta_category TEXT[] DEFAULT NULL,
    p_ai_meta_influencer TEXT[] DEFAULT NULL,
    p_ai_meta_season TEXT[] DEFAULT NULL,
    p_ai_meta_time_of_day TEXT[] DEFAULT NULL,
    p_ai_meta_activity_type TEXT[] DEFAULT NULL,
    p_ai_meta_special_tag TEXT[] DEFAULT NULL,
    p_ai_meta_kpop TEXT[] DEFAULT NULL,
    p_ai_meta_target_age TEXT[] DEFAULT NULL,
    p_ai_meta_target_audience TEXT[] DEFAULT NULL,
    p_ai_meta_landmark TEXT[] DEFAULT NULL,
    p_ai_meta_city TEXT[] DEFAULT NULL,
    p_ai_meta_country TEXT[] DEFAULT NULL,
    p_ai_meta_district TEXT[] DEFAULT NULL,
    p_ai_meta_neighborhood TEXT[] DEFAULT NULL,
    p_ai_meta_place TEXT[] DEFAULT NULL,
    p_ai_places JSONB DEFAULT NULL,
    p_ai_model VARCHAR(50) DEFAULT NULL,
    p_ai_confidence NUMERIC(3,2) DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
    v_places_count SMALLINT;
BEGIN
    -- post_url 존재 확인
    IF NOT EXISTS (SELECT 1 FROM public.blog_post WHERE post_url = p_post_url) THEN
        RETURN jsonb_build_object(
            'success', false,
            'error', 'post_url not found'
        );
    END IF;
    
    -- 장소 개수 계산 (있는 경우)
    v_places_count := CASE 
        WHEN p_ai_places IS NOT NULL 
        THEN jsonb_array_length(p_ai_places)::SMALLINT
        ELSE NULL
    END;
    
    -- AI 분석 결과 업데이트 (COALESCE로 NULL이면 기존 값 유지)
    UPDATE public.blog_post SET
        ai_summary = COALESCE(p_ai_summary, ai_summary),
        ai_key_points = COALESCE(p_ai_key_points, ai_key_points),
        ai_meta_category = COALESCE(p_ai_meta_category, ai_meta_category),
        ai_meta_influencer = COALESCE(p_ai_meta_influencer, ai_meta_influencer),
        ai_meta_season = COALESCE(p_ai_meta_season, ai_meta_season),
        ai_meta_time_of_day = COALESCE(p_ai_meta_time_of_day, ai_meta_time_of_day),
        ai_meta_activity_type = COALESCE(p_ai_meta_activity_type, ai_meta_activity_type),
        ai_meta_special_tag = COALESCE(p_ai_meta_special_tag, ai_meta_special_tag),
        ai_meta_kpop = COALESCE(p_ai_meta_kpop, ai_meta_kpop),
        ai_meta_target_age = COALESCE(p_ai_meta_target_age, ai_meta_target_age),
        ai_meta_target_audience = COALESCE(p_ai_meta_target_audience, ai_meta_target_audience),
        ai_meta_landmark = COALESCE(p_ai_meta_landmark, ai_meta_landmark),
        ai_meta_city = COALESCE(p_ai_meta_city, ai_meta_city),
        ai_meta_country = COALESCE(p_ai_meta_country, ai_meta_country),
        ai_meta_district = COALESCE(p_ai_meta_district, ai_meta_district),
        ai_meta_neighborhood = COALESCE(p_ai_meta_neighborhood, ai_meta_neighborhood),
        ai_meta_place = COALESCE(p_ai_meta_place, ai_meta_place),
        ai_places = COALESCE(p_ai_places, ai_places),
        ai_places_count = COALESCE(v_places_count, ai_places_count),
        ai_model = COALESCE(p_ai_model, ai_model),
        ai_confidence = COALESCE(p_ai_confidence, ai_confidence),
        ai_analyzed_at = NOW(),
        last_processed_at = NOW()
    WHERE post_url = p_post_url;
    
    RETURN jsonb_build_object(
        'success', true,
        'post_url', p_post_url,
        'places_count', v_places_count
    );
END;
$$;

COMMENT ON FUNCTION upsert_blog_post_ai_analysis IS 
'AI 분석 결과를 blog_post 테이블의 ai_* 필드에 저장';


-- ╔═══════════════════════════════════════════════════════════════════════════╗
-- ║                                                                           ║
-- ║                               3. 뷰 (VIEW)                                ║
-- ║                                                                           ║
-- ╚═══════════════════════════════════════════════════════════════════════════╝

/*
 ***********************************************************************************************
 * VIEW: 장소 검색용 뷰
 ***********************************************************************************************
 * 설명: ai_places JSONB를 행으로 펼쳐서 장소별 검색 가능하게 함
 * 용도: 특정 장소가 포함된 포스트 검색
 * 
 * 쿼리 예시:
 *   SELECT * FROM blog_post_places WHERE city = '서울';
 *   SELECT * FROM blog_post_places WHERE place_name LIKE '%맛집%';
 *   SELECT * FROM blog_post_places WHERE place_type = 'restaurant';
 *   SELECT * FROM blog_post_places WHERE country = 'KR' AND city = '부산';
 ***********************************************************************************************
 */
CREATE OR REPLACE VIEW public.blog_post_places AS
SELECT 
    -- 포스트 정보
    bp.id,
    bp.post_url,
    bp.title,
    bp.author_name,
    bp.blog_name,
    bp.published_date,
    bp.platform,
    bp.view_count,
    bp.like_count,
    bp.thumbnail_url,
    
    -- 장소 기본 정보
    place.value->>'place_name' AS place_name,
    place.value->>'place_name_en' AS place_name_en,
    place.value->>'place_name_native' AS place_name_native,
    place.value->>'place_type' AS place_type,
    
    -- 위치 정보
    place.value->>'country' AS country,
    place.value->>'city' AS city,
    place.value->>'district' AS district,
    place.value->>'neighborhood' AS neighborhood,
    place.value->>'landmark' AS landmark,
    place.value->>'address' AS address,
    (place.value->>'latitude')::NUMERIC AS latitude,
    (place.value->>'longitude')::NUMERIC AS longitude,
    
    -- 시간 정보 (이벤트/축제용)
    place.value->>'period' AS period,
    place.value->>'start_date' AS start_date,
    place.value->>'end_date' AS end_date,
    place.value->>'operation_hours' AS operation_hours,
    
    -- 상세 정보
    place.value->'prices' AS prices,
    place.value->'recommend_menu' AS recommend_menu,
    place.value->'travel_tips' AS travel_tips,
    place.value->>'notice' AS notice,
    place.value->>'review_summary' AS review_summary,
    (place.value->>'reservation_required')::BOOLEAN AS reservation_required,
    
    -- 포스트 내 위치
    (place.value->>'order_in_post')::INTEGER AS order_in_post
    
FROM public.blog_post bp
CROSS JOIN LATERAL jsonb_array_elements(bp.ai_places) AS place(value)
WHERE bp.ai_places IS NOT NULL 
    AND bp.is_active = TRUE 
    AND bp.is_deleted = FALSE;
