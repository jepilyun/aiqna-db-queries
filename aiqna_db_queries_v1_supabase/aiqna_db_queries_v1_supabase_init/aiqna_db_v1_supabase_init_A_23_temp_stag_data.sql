/*
 * aiqna db for web service (Meta Stags Table)
 * Database Name 'aiqna'
 *
 * Created 2024-10-12
 * Updated 2025-10-12
 */

-- 필요 확장 (유사도 검색 시)
-- CREATE EXTENSION IF NOT EXISTS pg_trgm;

--------------------------------------------------------------------------------
-- TABLE: temp_stag_data
--  - AI로 추출된 태그 임시 저장 (stag_code 매핑 전)
--------------------------------------------------------------------------------
CREATE TABLE public.temp_stag_data (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  -- 추출된 스태그 정보
  stag_name VARCHAR(255) NOT NULL,
  
  -- 소스 정보
  source_type VARCHAR(50)   NOT NULL,
  source_id   VARCHAR(1023) NOT NULL,

  -- 매핑 정보
  stag_code VARCHAR(96) NULL,
  
  -- 관리 정보
  admin_message VARCHAR(1023) NULL,
  is_processed  BOOLEAN NOT NULL DEFAULT FALSE,
  processed_at  TIMESTAMPTZ NULL,
  
  -- 시스템 정보
  created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMPTZ          DEFAULT CURRENT_TIMESTAMP,

  -- FK
  CONSTRAINT temp_stag_data_stag_code_fkey
    FOREIGN KEY (stag_code)
    REFERENCES public.stags (stag_code)
    ON UPDATE CASCADE ON DELETE SET NULL,

  -- 제약조건
  CONSTRAINT temp_stag_data_source_type_check 
    CHECK (source_type IN ('youtube_video', 'instagram_post', 'blog_post', 'text')),
  CONSTRAINT temp_stag_data_stag_name_not_empty_check 
    CHECK (LENGTH(TRIM(stag_name)) > 0),

  -- 중복 방지: 같은 소스에서 같은 스태그명은 한 번만
  CONSTRAINT temp_stag_data_unique_source_stag
    UNIQUE (source_type, source_id, stag_name)
) TABLESPACE pg_default;

-- =======================================
-- INDEXES
-- =======================================
CREATE INDEX IF NOT EXISTS temp_stag_data_unprocessed_idx
  ON public.temp_stag_data (is_processed, created_at)
  WHERE is_processed = FALSE;

CREATE INDEX IF NOT EXISTS temp_stag_data_stag_name_idx
  ON public.temp_stag_data (stag_name, created_at DESC);

CREATE INDEX IF NOT EXISTS temp_stag_data_stag_name_trgm_idx
  ON public.temp_stag_data USING gin (stag_name gin_trgm_ops);

CREATE INDEX IF NOT EXISTS temp_stag_data_source_idx
  ON public.temp_stag_data (source_type, source_id, created_at DESC);

CREATE INDEX IF NOT EXISTS temp_stag_data_stag_code_idx
  ON public.temp_stag_data (stag_code, created_at DESC)
  WHERE stag_code IS NOT NULL;

CREATE INDEX IF NOT EXISTS temp_stag_data_processed_idx
  ON public.temp_stag_data (is_processed, processed_at DESC)
  WHERE is_processed = TRUE;

CREATE INDEX IF NOT EXISTS temp_stag_data_created_at_idx
  ON public.temp_stag_data (created_at DESC);

-- =======================================
-- RLS
-- =======================================
ALTER TABLE public.temp_stag_data ENABLE ROW LEVEL SECURITY;

CREATE POLICY "temp_stag_data are visible to everyone"
  ON public.temp_stag_data FOR SELECT 
  TO authenticated, anon 
  USING (TRUE);

CREATE POLICY "Service role can manage temp_stag_data"
  ON public.temp_stag_data FOR ALL 
  TO service_role 
  USING (TRUE) 
  WITH CHECK (TRUE);

-- =======================================
-- TRIGGERS
-- =======================================
CREATE TRIGGER trigger_update_temp_stag_data_updated_at
  BEFORE UPDATE ON public.temp_stag_data
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE FUNCTION auto_mark_processed_on_temp_stag_code()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
    IF NEW.stag_code IS NOT NULL AND OLD.stag_code IS NULL THEN
        NEW.is_processed := TRUE;
        NEW.processed_at := CURRENT_TIMESTAMP;
    END IF;
    RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_auto_mark_processed_stag
  BEFORE UPDATE ON public.temp_stag_data
  FOR EACH ROW
  WHEN (NEW.stag_code IS NOT NULL AND OLD.stag_code IS NULL)
  EXECUTE FUNCTION auto_mark_processed_on_temp_stag_code();

-- =======================================
-- FUNCTIONS
-- =======================================

-- 추출된 스태그명 저장 (BIGINT 반환)
CREATE OR REPLACE FUNCTION public.add_temp_stag_data(
    p_stag_name   VARCHAR(255),
    p_source_type VARCHAR(50),
    p_source_id   VARCHAR(1023)
)
RETURNS BIGINT
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
    v_id BIGINT;
BEGIN
    INSERT INTO public.temp_stag_data (
        stag_name, source_type, source_id
    ) VALUES (
        TRIM(p_stag_name), p_source_type, p_source_id
    )
    ON CONFLICT (source_type, source_id, stag_name) DO NOTHING
    RETURNING id INTO v_id;
    
    RETURN v_id;
END;
$$;

-- stag_code 매핑 및 자동 처리
CREATE OR REPLACE FUNCTION public.map_temp_stag_data_to_stag_code(
    p_temp_stag_data_id BIGINT,
    p_stag_code VARCHAR(96),
    p_admin_message VARCHAR(1023) DEFAULT NULL
)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
BEGIN
    UPDATE public.temp_stag_data
    SET stag_code     = p_stag_code,
        admin_message = p_admin_message,
        is_processed  = TRUE,
        processed_at  = CURRENT_TIMESTAMP,
        updated_at    = CURRENT_TIMESTAMP
    WHERE id = p_temp_stag_data_id;
END;
$$;

-- 미처리 스태그명 목록 조회 (관리자용)
CREATE OR REPLACE FUNCTION public.get_unprocessed_temp_stag_data(
    p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
    stag_name VARCHAR(255),
    source_type VARCHAR(50),
    source_id VARCHAR(1023),
    occurrence_count BIGINT,
    first_seen TIMESTAMPTZ,
    last_seen TIMESTAMPTZ
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
    SELECT 
        stag_name,
        source_type,
        source_id,
        COUNT(*)        AS occurrence_count,
        MIN(created_at) AS first_seen,
        MAX(created_at) AS last_seen
    FROM public.temp_stag_data
    WHERE is_processed = FALSE
    GROUP BY stag_name, source_type, source_id
    ORDER BY occurrence_count DESC, last_seen DESC
    LIMIT p_limit;
$$;

-- 스태그명 검색 (유사 매칭)
CREATE OR REPLACE FUNCTION public.search_similar_temp_stag_names(
    p_stag_name VARCHAR(255),
    p_limit INTEGER DEFAULT 10
)
RETURNS TABLE (
    stag_name VARCHAR(255),
    stag_code VARCHAR(96),
    occurrence_count BIGINT,
    is_processed BOOLEAN,
    similarity_score REAL
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
    SELECT 
        ts.stag_name,
        ts.stag_code,
        COUNT(*) AS occurrence_count,
        ts.is_processed,
        similarity(ts.stag_name, p_stag_name) AS similarity_score
    FROM public.temp_stag_data ts
    WHERE ts.stag_name % p_stag_name
    GROUP BY ts.stag_name, ts.stag_code, ts.is_processed
    ORDER BY similarity_score DESC, occurrence_count DESC
    LIMIT p_limit;
$$;

-- 스태그명 일괄 매핑
CREATE OR REPLACE FUNCTION public.batch_map_temp_stag_name_to_code(
    p_stag_name VARCHAR(255),
    p_stag_code VARCHAR(96),
    p_admin_message VARCHAR(1023) DEFAULT NULL
)
RETURNS INTEGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
DECLARE
    v_updated_count INTEGER;
BEGIN
    UPDATE public.temp_stag_data
    SET stag_code     = p_stag_code,
        admin_message = p_admin_message,
        is_processed  = TRUE,
        processed_at  = CURRENT_TIMESTAMP,
        updated_at    = CURRENT_TIMESTAMP
    WHERE stag_name = p_stag_name
      AND is_processed = FALSE;
    
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;
    RETURN v_updated_count;
END;
$$;

-- 통계 조회
CREATE OR REPLACE FUNCTION public.get_temp_stag_data_statistics()
RETURNS TABLE (
    total_count BIGINT,
    processed_count BIGINT,
    unprocessed_count BIGINT,
    unique_stag_names BIGINT,
    mapped_stag_codes BIGINT
)
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = pg_catalog, public
AS $$
    SELECT 
        COUNT(*) AS total_count,
        COUNT(*) FILTER (WHERE is_processed = TRUE)  AS processed_count,
        COUNT(*) FILTER (WHERE is_processed = FALSE) AS unprocessed_count,
        COUNT(DISTINCT stag_name) AS unique_stag_names,
        COUNT(DISTINCT stag_code) FILTER (WHERE stag_code IS NOT NULL) AS mapped_stag_codes
    FROM public.temp_stag_data;
$$;
